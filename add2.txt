(
(Imports
  Prelude ;import "Prelude"
)
(Types
  (Num Prelude Num) ;Num = Prelude.Num
  (Bool Prelude Bool)
  (String Prelude String)
  (CmdArgs Prelude CmdArgs)

  ; Funciones importadas
  (add Prelude add) ;add = Prelude.add-i-i
  (gtz Prelude gtz) ;greater than zero
  (dec Prelude dec) ;decrement
  (print Prelude print)
  (itos Prelude itos) ;Num to String
)
(Structs
  (SELF 
    (a Num)
    (b Num)
    (zero Num)
    (MAIN MAIN) ;Es necesario exportar la función MAIN, con el nombre MAIN
  )
  (mult-args
    (a Num)
    (b Num)
    (r Num)
  )
  (mult-regs
    (SELF SELF)
    ; Args
    (a Num)
    (b Num)
    ; Return
    (r Num)

    (n Num)
    (m Num)
    (r Num)
    (cond Bool)

    (add add)
    (gtz gtz)
    (dec dec)
  )
  (sum-args
    (a Num)
    (b Num)
  )
  (sum-regs
    ; Especiales
    (SELF SELF)
    (ARGS sum-args)

    ; Variables
    (a Num)
    (b Num)
    (r Num)
    (rs Num)

    ; Funciones
    (add add)
    (mult mult)
    (print print)
    (itos itos)
  )
  (main-regs
    (SELF SELF)
    (ARGS empty-args)
    (a Num)
    (b Num)
    (sum sum) ; sum está en la sección Functions, no está definido aún...
  )
  (empty-args) ; Struct vacío
)

;Definiciones de funciones
;Las Funciones son tipos, así que esta sección define más tipos
(Functions
  (mult

    ; El Struct que representa los registros de la función
    ; Las funciones que interactúen con esta funcion no pueden leer ni
    ; escribir los campos de este struct
    mult-regs

    ;;; Registros de entrada
    ; Estos registros se marcan como solo escritura para el código externo,
    ; es decir una función que vaya a invocar esta función, puede escribir
    ; estos campos (pero no leerlos), y no puede escribir ningún otro.
    (in a b)

    ;;; Registros de salida
    ; Estos registros se marcan como solo lectura para el código externo,
    ; es decir una función que vaya a invocar esta función, puede leer
    ; estos campos (pero no escribirlos), y no puede leer ningún otro.
    (out r)

    (Code
      (get n ARGS a)
      (get m ARGS b)
      (get r SELF zero)
      (lbl start)
      (new gtz)
      (set gtz a m)
      (call gtz)
      (get cond gtz r)
      (ifn end cond)
      (new add)
      (set add a r)
      (set add b n)
      (call add)
      (get r add r)
      (new dec)
      (set dec a m)
      (call dec)
      (get m dec r)
      (jmp start)
      (lbl end)
      (set ARGS r r)
      (end)
    )
  )
  (sum
    (Code
      (get a ARGS a)  ;a = ARGS.a
      (get b ARGS b)  ;a = ARGS.b
      (new mult) ; add o mult
      (set mult a a)   ;mult.a = a
      (set mult b b)   ;mult.b = b
      (call mult)
      (get r mult r)   ;r = mult.r
      (new itos)
      (set itos a r)  ;itos.a = r
      (call itos)
      (get rs itos r)   ;rs = itos.r
      (new print)
      (set print a rs)  ;print.a = rs
      (call print)
      (end)
    )
  )

  (MAIN
    empty-args
    main-regs
    (Code
      (get a SELF a)  ;a = SELF.a
      (get b SELF b)  ;b = SELF.b
      (new sum)
      (set sum a a) ;sum.a = a
      (set sum b b) ;sum.b = b
      (call sum)    ;sum()
      (end)
    )
  )
)

; Constantes del módulo
(Constants
  (a num 5)
  (b num 3)
  (zero num 0)
  ; En estos, "num" es la operación. Existen más operaciones:

  ; int recibe un número, devuelve un valor tipo Prelude.Num
  ; float recibe un número, devuelve un valor tipo Prelude.Float
  ; string recibe un string, devuelve un valor tipo Prelude.String
  ; type recibe un tipo, devuelve un valor tipo Prelude.Type
  ; function recibe un tipo función, devuelve un valor tipo Prelude.Function

  ; type y function son diferentes porque type es solo información de tipo,
  ; es para que lo usen los módulos y para reflexión, en cambio function
  ; es un objeto ejecutable, es para usar funciones como valores, como en
  ; los lenguajes con funciones de primera clase.

  ; La operacion num no debería existir, solo int y float
)
)