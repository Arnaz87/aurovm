(
(Imports
  Prelude ;import "Prelude"
)

;Tipos importados de otros módulos
;A pesar del nombre, esta no es la única sección que define tipos
(Types
  (Int Prelude Int) ;Int = Prelude.Int
  (String Prelude String)
  (CmdArgs Prelude CmdArgs)

  ; Funciones importadas
  (add Prelude add ;(add-i-i)) ;add = Prelude.add-i-i
  (print Prelude print)
  (itos Prelude itos ;(i-to-s)) ;Int to String
)

;Esta sección define más tipos
(Structs
  (SELF 
    (a Int)
    (b Int)
    (MAIN MAIN)
  )
  (sum-args
    (a Int)
    (b Int)
  )
  (sum-regs
    ; Especiales
    (SELF SELF)
    (ARGS sum-args)

    ; Variables
    (a Int)
    (b Int)
    (r Int)
    (rs String)

    ; Funciones
    (add add)
    (print print)
    (itos itos)
  )
  (main-regs
    (SELF SELF)
    (ARGS empty-args)
    (a Int)
    (b Int)
    (sum sum) ; sum está en la sección Functions, no está definido aún...
  )
  (empty-args) ; Struct vacío
)

;Definiciones de funciones
;Las Funciones son tipos, así que esta sección define más tipos
(Functions
  (sum
    ; Struct de los argumentos (y valores devueltos)
    ;   Esta es la estructura que el resto del programa asume cuando usa
    ;   esta función, pero no es compatible con el Struct original.
    sum-args
    ; Estructura interna de la función
    ;   El resto del programa no sabe la estructura interna de la función,
    ;   y no hay manera de aceder a este Struct.
    sum-regs
    (Code
      (get a ARGS a)  ;a = ARGS.a
      (get b ARGS b)  ;a = ARGS.b
      (new add)
      (set add a a)   ;add.a = a
      (set add b b)   ;add.b = b
      (call add)
      (get r add r)   ;r = add.r
      (new itos)
      (set itos a r)  ;itos.a = r
      (call itos)
      (get rs itos r)   ;rs = itos.r
      (new print)
      (set print a rs)  ;print.a = rs
      (call print)
      (end)
    )
    ; Código legible:
    ; r = add(ARGS.a, ARGS.b)
    ; print(itos(r))
  )

  (MAIN
    empty-args
    main-regs
    (Code
      (get a SELF a)  ;a = SELF.a
      (get b SELF b)  ;b = SELF.b
      (new sum)
      (set sum a a) ;sum.a = a
      (set sum b b) ;sum.b = b
      (call sum)    ;sum()
      (end)
    )
  )
)

; Constantes del módulo
(Constants
  (a num 4)
  (b num 5)
  ; En estas dos, "num" es la operación. Existen más operaciones:

  ; int recibe un número, devuelve un valor tipo Prelude.Int
  ; string recibe un string, devuelve un valor tipo Prelude.String
  ; type recibe un tipo, devuelve un valor tipo Prelude.Type
  ; function recibe un tipo función, devuelve un valor tipo Prelude.Function

  ; type y function son diferentes porque type es solo información de tipo,
  ; es para que lo usen los módulos y para reflexión, en cambio function
  ; es un objeto ejecutable, es para usar funciones como valores, como en
  ; los lenguajes con funciones de primera clase.

  ; La operacion num no debería existir, solo int y float
)
; Esto en realidad debería ser un Array diferente, y que la función LOAD
; se encargue de asignar las constantes al módulo.
; Pero eso complicaría un poco las cosas con los tipos, habría que crear un
; tipo automático para representar el objeto de constantes, o habría que
; pasarle a LOAD un array de valores sin tipo, ambas alternativas son feas.
)