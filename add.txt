(
(Imports
  Prelude ;import "Prelude"
)

;Tipos importados de otros módulos
;A pesar del nombre, esta no es la única sección que define tipos
(Types
  (Num Prelude Num) ;Num = Prelude.Num
  (Bool Prelude Bool)
  (String Prelude String)
  (CmdArgs Prelude CmdArgs)

  ; Funciones importadas
  (add Prelude add) ;add = Prelude.add-i-i
  (gtz Prelude gtz) ;greater than zero
  (dec Prelude dec) ;decrement
  (print Prelude print)
  (itos Prelude itos) ;Num to String
)

;Esta sección define más tipos
(Structs
  (SELF 
    (a Num)
    (b Num)
    (zero Num)
    (MAIN MAIN)
  )
  (mult-args
    (a Num)
    (b Num)
    (r Num)
  )
  (mult-regs
    (SELF SELF)
    (ARGS sum-args)

    (n Num)
    (m Num)
    (r Num)
    (cond Bool)

    (add add)
    (gtz gtz)
    (dec dec)
  )
  (sum-args
    (a Num)
    (b Num)
  )
  (sum-regs
    ; Especiales
    (SELF SELF)
    (ARGS sum-args)

    ; Variables
    (a Num)
    (b Num)
    (r Num)
    (rs Num)

    ; Funciones
    (add add)
    (mult mult)
    (print print)
    (itos itos)
  )
  (main-regs
    (SELF SELF)
    (ARGS empty-args)
    (a Num)
    (b Num)
    (sum sum) ; sum está en la sección Functions, no está definido aún...
  )
  (empty-args) ; Struct vacío
)

;Definiciones de funciones
;Las Funciones son tipos, así que esta sección define más tipos
(Functions
  (mult
    mult-args
    mult-regs
    (Code

      ;(function mult (n, m)
        r = 0
        repeat:
          if not m>0 break
          r = add(r, n)
          m--
        return r
      end)

      ;(
        n = Args.a
        m = Args.b
        r = 0
        :start
        gtz.a = m
        gtz()
        cond = gtz.r
        goto :end ifnot cond
        add.a = r
        add.b = n
        add()
        r = add.r
        dec.a = m
        dec()
        m = dec.r
        goto :start
        :end
        Args.r = r
        return
      )


      (get n ARGS a)
      (get m ARGS b)
      (get r SELF zero)
      (lbl start)
      (new gtz)
      (set gtz a m)
      (call gtz)
      (get cond gtz r)
      (ifn end cond)
      (new add)
      (set add a r)
      (set add b n)
      (call add)
      (get r add r)
      (new dec)
      (set dec a m)
      (call dec)
      (get m dec r)
      (jmp start)
      (lbl end)
      (set ARGS r r)
      (end)
    )
  )
  (sum
    ; Struct de los argumentos (y valores devueltos)
    ;   Esta es la estructura que el resto del programa asume cuando usa
    ;   esta función, pero no es compatible con el Struct original.
    sum-args
    ; Estructura interna de la función
    ;   El resto del programa no sabe la estructura interna de la función,
    ;   y no hay manera de aceder a este Struct.
    sum-regs
    (Code
      (get a ARGS a)  ;a = ARGS.a
      (get b ARGS b)  ;a = ARGS.b
      (new mult) ; add o mult
      (set mult a a)   ;mult.a = a
      (set mult b b)   ;mult.b = b
      (call mult)
      (get r mult r)   ;r = mult.r
      (new itos)
      (set itos a r)  ;itos.a = r
      (call itos)
      (get rs itos r)   ;rs = itos.r
      (new print)
      (set print a rs)  ;print.a = rs
      (call print)
      (end)
    )
    ; Código legible:
    ; r = add(ARGS.a, ARGS.b)
    ; print(itos(r))
  )

  (MAIN
    empty-args
    main-regs
    (Code
      (get a SELF a)  ;a = SELF.a
      (get b SELF b)  ;b = SELF.b
      (new sum)
      (set sum a a) ;sum.a = a
      (set sum b b) ;sum.b = b
      (call sum)    ;sum()
      (end)
    )
  )
)

; Constantes del módulo
(Constants
  (a num 5)
  (b num 3)
  (zero num 0)
  ; En estos, "num" es la operación. Existen más operaciones:

  ; int recibe un número, devuelve un valor tipo Prelude.Num
  ; float recibe un número, devuelve un valor tipo Prelude.Float
  ; string recibe un string, devuelve un valor tipo Prelude.String
  ; type recibe un tipo, devuelve un valor tipo Prelude.Type
  ; function recibe un tipo función, devuelve un valor tipo Prelude.Function

  ; type y function son diferentes porque type es solo información de tipo,
  ; es para que lo usen los módulos y para reflexión, en cambio function
  ; es un objeto ejecutable, es para usar funciones como valores, como en
  ; los lenguajes con funciones de primera clase.

  ; La operacion num no debería existir, solo int y float
)
)